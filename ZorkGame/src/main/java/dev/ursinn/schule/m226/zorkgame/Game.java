/* * MIT License * * Copyright (c) 2020 Ursin Filli * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. * */package dev.ursinn.schule.m226.zorkgame;import java.util.ArrayList;import java.util.concurrent.atomic.AtomicBoolean;public class Game {    private Parser parser;    private Room currentRoom, lastRoom;    private Room outside, buildingA, buildingB, buildingC, testRoom, lab, office, roof, reception, secretOffice;    private ArrayList<Room> rooms;    private Inventory inventory;    /**     * Create the game and initialise its internal map.     */    public Game() {        rooms = new ArrayList<>();        inventory = new Inventory(3);        parser = new Parser();        ArrayList<Question> questions_reception = new ArrayList<>();        questions_reception.add(new Question("Hallo?", "Hallo", null));        questions_reception.add(new Question("Code?", "Da", new Item(ItemType.CODE, 0, "Door Code", null)));        ArrayList<Person> persons_reception = new ArrayList<>();        persons_reception.add(new Person(questions_reception));        // Create all the rooms and link their exits together.        outside = new Room("Outside", null, null, false);        buildingC = new Room("Building C", null, null, false);        reception = new Room("Reception", null, persons_reception, true);        buildingB = new Room("Building B", null, null, true);        lab = new Room("Lab", null, null, true);        office = new Room("Office", null, null, true);        buildingA = new Room("Building A", null, null, true);        testRoom = new Room("Test Room", null, null, true);        roof = new Room("Roof", null, null, true);        secretOffice = new Room("Secret Office", null, null, true);        // initialise room exits        outside.setExits(buildingA, buildingB, buildingC, null);        buildingC.setExits(outside, null, reception, null);        reception.setExits(buildingC, secretOffice, null, null);        buildingB.setExits(null, lab, office, outside);        lab.setExits(null, null, null, buildingB);        office.setExits(buildingB, roof, null, null);        buildingA.setExits(null, testRoom, outside, null);        testRoom.setExits(null, null, null, buildingA);        roof.setExits(null, null, null, office);        secretOffice.setExits(null, null, null, reception);        rooms.add(outside);        rooms.add(buildingC);        rooms.add(reception);        rooms.add(buildingB);        rooms.add(lab);        rooms.add(office);        rooms.add(buildingA);        rooms.add(testRoom);        rooms.add(roof);        rooms.add(secretOffice);        currentRoom = outside; // start game outside        lastRoom = outside;    }    /**     * Main play routine.  Loops until end of play.     */    public void play() {        printWelcome();        // Enter the main command loop.  Here we repeatedly read commands and        // execute them until the game is over.        boolean finished = false;        while (!finished) {            Command command = parser.getCommand();            finished = processCommand(command);        }        System.out.println("Thank you for playing.  Good bye.");    }    /**     * Print out the opening message for the player.     */    private void printWelcome() {        System.out.println();        System.out.println("Welcome to Zork!");        System.out.println("Zork is a simple adventure game.");        System.out.println("Type 'help' if you need help.");        System.out.println();        System.out.println(currentRoom.longDescription());    }    /**     * Given a command, process (that is: execute) the command.     * If this command ends the game, true is returned, otherwise false is     * returned.     */    private boolean processCommand(Command command) {        if (command.isUnknown()) {            System.out.println("I don't know what you mean...");            return false;        }        String commandWord = command.getCommandWord();        switch (commandWord) {            case "help":                printHelp();                break;            case "go":                goRoom(command);                break;            case "quit":                if (command.hasSecondWord()) {                    System.out.println("Quit what?");                } else {                    return true; // signal that we want to quit                }                break;            case "back":                Room back = lastRoom;                lastRoom = currentRoom;                currentRoom = back;                System.out.println(currentRoom.longDescription());                break;            case "pickup":                pickup();                break;            case "search":                search();                break;            case "use":                use();                break;            case "map":                rooms.forEach(room -> System.out.println(room.shortDescription()));                break;        }        return false;    }    private void use() {        inventory.getItems().forEach(item -> {            if (item.getType() == ItemType.ITEM) {                // TODO Use Item            }        });    }    private void search() {        currentRoom.setSearched(true);        currentRoom.getItems().forEach(item -> {            // TODO Find Items        });    }    private void pickup() {        if (!currentRoom.isSearched()) {            // TODO First Search!            return;        }        currentRoom.getItems().forEach(item -> {            if (item.getContains() == null) {                if (!inventory.addItem(item)) {                    // TODO Inv Full                }            } else {                if (!inventory.addItem(item.getContains())) {                    // TODO Inv Full                }            }        });    }    /*     * implementations of user commands:     */    /**     * Print out some help information.     * Here we print some stupid, cryptic message and a list of the     * command words.     */    private void printHelp() {        System.out.println("You are lost. You are alone. You wander");        System.out.println("around at Monash Uni, Peninsula Campus.");        System.out.println();        System.out.println("Your command words are:");        System.out.println(parser.showCommands());    }    /**     * Try to go to one direction. If there is an exit, enter the new     * room, otherwise print an error message.     */    private void goRoom(Command command) {        // if there is no second word, we don't know where to go...        if (!command.hasSecondWord()) {            System.out.println("Go where?");        } else {            String direction = command.getSecondWord();            // Try to leave current room.            Room nextRoom = currentRoom.nextRoom(direction);            if (nextRoom == null)                System.out.println("There is no door!");            else {                if (nextRoom.isLocked()) {                    if (nextRoom.shortDescription().equalsIgnoreCase("Reception")) {                        if (unlockRoom(ItemType.KEY, "Reception Key"))                            nextRoom.setLocked(false);                    }                    if (nextRoom.shortDescription().equalsIgnoreCase("Secret Office")) {                        if (unlockRoom(ItemType.CODE, "Door Code") && unlockRoom(ItemType.KEY, "Secret Office"))                            nextRoom.setLocked(false);                    }                }                lastRoom = currentRoom;                currentRoom = nextRoom;                System.out.println(currentRoom.longDescription());            }        }    }    private boolean unlockRoom(ItemType type, String desc) {        AtomicBoolean back = new AtomicBoolean(false);        inventory.getItems().forEach(item -> {            if (item.getType() == type) {                if (item.getName().equalsIgnoreCase(desc))                    back.set(true);            }        });        return back.get();    }}